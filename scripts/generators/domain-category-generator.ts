/**
 * Domain Category Generator
 *
 * Generates domain-to-category mappings from upstream index.json metadata.
 * The upstream now provides ui_category directly, eliminating the need for
 * a separate mapping file.
 *
 * Generated output: src/generated/domainCategories.ts
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Domain metadata from upstream index.json
 */
export interface DomainInfo {
  domain: string;
  title: string;
  description: string;
  description_short: string;
  description_medium?: string;
  file: string;
  path_count: number;
  schema_count: number;
  complexity: string;
  is_preview: boolean;
  requires_tier: string;
  domain_category: string;
  ui_category: string; // New field from upstream - provides UI-friendly category directly
  aliases?: string[];
  use_cases?: string[];
  related_domains?: string[];
  icon: string;
  logo_svg?: string;
  primary_resources?: Array<{
    name: string;
    description: string;
    description_short: string;
    tier: string;
    icon: string;
    category: string;
    supports_logs: boolean;
    supports_metrics: boolean;
    dependencies: {
      required: string[];
      optional: string[];
    };
    relationship_hints: string[];
  }>;
  primary_resources_simple?: string[];
}

/**
 * Index.json structure from upstream
 */
interface IndexJson {
  version: string;
  timestamp: string;
  specifications: DomainInfo[];
}

/**
 * Load domain metadata from upstream index.json
 */
export function loadDomainMetadata(indexPath: string): DomainInfo[] {
  if (!fs.existsSync(indexPath)) {
    console.warn(`Warning: index.json not found at ${indexPath}`);
    return [];
  }

  const content = fs.readFileSync(indexPath, 'utf-8');
  const indexData = JSON.parse(content) as IndexJson;

  return indexData.specifications;
}

/**
 * Generate the domainCategories.ts file from index.json metadata.
 * Uses ui_category directly from upstream - no mapping file needed.
 */
export function generateDomainCategoriesFile(indexPath: string, outputPath: string): void {
  const domains = loadDomainMetadata(indexPath);

  if (domains.length === 0) {
    console.error('Error: No domain metadata found in index.json');
    return;
  }

  // Output metadata interface (uses camelCase for TypeScript convention)
  interface OutputDomainMetadata {
    title: string;
    description: string;
    description_short: string;
    description_medium: string;
    icon: string;
    primary_resources?: Array<{
      name: string;
      description: string;
      description_short: string;
      tier: string;
      icon: string;
      category: string;
    }>;
    primary_resources_simple?: string[];
    use_cases: string[];
    complexity: string;
    requires_tier: string;
    isPreview: boolean;
  }

  // Build domainâ†’ui_category mapping (single source of truth from upstream)
  const domainToUiCategory: Record<string, string> = {};
  const domainMetadata: Record<string, OutputDomainMetadata> = {};

  for (const domain of domains) {
    // Use ui_category directly from upstream
    domainToUiCategory[domain.domain] = domain.ui_category;

    // Extract simplified primary_resources for output (just the essential fields)
    const simplifiedResources = domain.primary_resources?.map((r) => ({
      name: r.name,
      description: r.description,
      description_short: r.description_short,
      tier: r.tier,
      icon: r.icon,
      category: r.category,
    }));

    domainMetadata[domain.domain] = {
      title: domain.title,
      description: domain.description,
      description_short: domain.description_short,
      description_medium: domain.description_medium ?? domain.description_short,
      icon: domain.icon,
      primary_resources: simplifiedResources,
      primary_resources_simple: domain.primary_resources_simple,
      use_cases: domain.use_cases ?? [],
      complexity: domain.complexity,
      requires_tier: domain.requires_tier,
      isPreview: domain.is_preview,
    };
  }

  // Collect unique UI categories
  const uiCategories = [...new Set(domains.map((d) => d.ui_category))].sort();

  // Generate TypeScript content
  const content = `/**
 * Auto-generated domain category mappings from upstream index.json.
 * DO NOT EDIT - This file is generated by scripts/generators/domain-category-generator.ts
 *
 * Source: docs/specifications/index.json
 * The upstream now provides ui_category directly - no mapping file needed.
 */

/**
 * UI category values as defined in F5 XC API specifications.
 * These are the ${uiCategories.length} categories from upstream's ui_category field.
 */
export const UI_CATEGORIES = ${JSON.stringify(uiCategories, null, 2)} as const;

/**
 * Type for UI category names
 */
export type UiCategory = typeof UI_CATEGORIES[number];

/**
 * Domain to UI category mapping.
 * Generated directly from upstream index.json ui_category field.
 * This is the single source of truth - no intermediate mapping needed.
 */
export const DOMAIN_TO_UI_CATEGORY: Record<string, UiCategory> = ${JSON.stringify(domainToUiCategory, null, 2)};

/**
 * Get the UI category for a domain.
 * Uses upstream ui_category directly.
 */
export function getUiCategoryForDomain(domain: string): UiCategory | undefined {
  return DOMAIN_TO_UI_CATEGORY[domain] as UiCategory | undefined;
}

/**
 * Primary resource info from upstream.
 */
export interface PrimaryResourceInfo {
  name: string;
  description: string;
  description_short: string;
  tier: string;
  icon: string;
  category: string;
}

/**
 * Domain metadata from upstream index.json.
 * Includes title, descriptions, icon, primary resources, use cases, and preview status.
 */
export const DOMAIN_METADATA: Record<string, {
  title: string;
  description: string;
  description_short: string;
  description_medium: string;
  icon: string;
  primary_resources?: PrimaryResourceInfo[];
  primary_resources_simple?: string[];
  use_cases: string[];
  complexity: string;
  requires_tier: string;
  isPreview: boolean;
}> = ${JSON.stringify(domainMetadata, null, 2)};

/**
 * Get metadata for a domain.
 */
export function getDomainMetadata(domain: string) {
  return DOMAIN_METADATA[domain];
}

/**
 * Get all domains belonging to a specific UI category.
 */
export function getDomainsForCategory(category: UiCategory): string[] {
  return Object.entries(DOMAIN_TO_UI_CATEGORY)
    .filter(([_, cat]) => cat === category)
    .map(([domain]) => domain);
}

/**
 * Get the full description for a domain.
 */
export function getDomainDescription(domain: string): string | undefined {
  return DOMAIN_METADATA[domain]?.description;
}

/**
 * Get the medium-length description for a domain.
 */
export function getDomainDescriptionMedium(domain: string): string | undefined {
  return DOMAIN_METADATA[domain]?.description_medium;
}

/**
 * Get use cases for a domain.
 */
export function getDomainUseCases(domain: string): string[] {
  return DOMAIN_METADATA[domain]?.use_cases ?? [];
}

/**
 * Check if a domain is in preview/beta status.
 */
export function isPreviewDomain(domain: string): boolean {
  return DOMAIN_METADATA[domain]?.isPreview ?? false;
}

/**
 * Get the tier requirement for a domain.
 */
export function getDomainTierRequirement(domain: string): string | undefined {
  return DOMAIN_METADATA[domain]?.requires_tier;
}

/**
 * Get the complexity level for a domain.
 */
export function getDomainComplexity(domain: string): string | undefined {
  return DOMAIN_METADATA[domain]?.complexity;
}

/**
 * Get primary resources for a domain (rich info with descriptions).
 */
export function getDomainPrimaryResources(domain: string): PrimaryResourceInfo[] {
  return DOMAIN_METADATA[domain]?.primary_resources ?? [];
}

/**
 * Get primary resource names for a domain (simple string array).
 */
export function getDomainPrimaryResourcesSimple(domain: string): string[] {
  return DOMAIN_METADATA[domain]?.primary_resources_simple ?? [];
}

// Legacy aliases for backwards compatibility
export const DOMAIN_TO_UPSTREAM_CATEGORY = DOMAIN_TO_UI_CATEGORY;
export const getLocalCategoryForDomain = getUiCategoryForDomain;
`;

  fs.writeFileSync(outputPath, content, 'utf-8');
  console.log(`Generated: ${outputPath}`);
  console.log(`  - ${domains.length} domains`);
  console.log(`  - ${uiCategories.length} UI categories: ${uiCategories.join(', ')}`);
}

// Allow running standalone
if (require.main === module) {
  const indexPath = path.join(__dirname, '..', '..', 'docs', 'specifications', 'api', 'index.json');
  const outputPath = path.join(__dirname, '..', '..', 'src', 'generated', 'domainCategories.ts');

  generateDomainCategoriesFile(indexPath, outputPath);
}
