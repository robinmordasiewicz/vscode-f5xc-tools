/**
 * Main generator script for F5 XC resource types and constants.
 *
 * This script orchestrates the generation of:
 * - src/generated/resourceTypesBase.ts - Auto-generated resource types from OpenAPI specs
 * - src/generated/constants.ts - Consolidated constants (namespaces, endpoints, icons)
 * - src/generated/index.ts - Barrel export for generated modules
 *
 * Usage: npx ts-node scripts/generate-resource-types.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import {
  generateResourceTypesFromDomainFiles,
  ParsedSpecInfo,
} from './generators/resource-type-generator';
import { writeConstantsFile } from './generators/constants-generator';
import { generateDomainCategoriesFile } from './generators/domain-category-generator';

// Use domain-based specs (new upstream format with x-ves-cli-domain)
const DOMAIN_DIR = path.join(__dirname, '..', 'docs', 'specifications', 'api', 'domains');
const SPECS_DIR = path.join(__dirname, '..', 'docs', 'specifications', 'api');
const GENERATED_DIR = path.join(__dirname, '..', 'src', 'generated');
const RESOURCE_TYPES_OUTPUT = path.join(GENERATED_DIR, 'resourceTypesBase.ts');
const CONSTANTS_OUTPUT = path.join(GENERATED_DIR, 'constants.ts');
const DOMAIN_CATEGORIES_OUTPUT = path.join(GENERATED_DIR, 'domainCategories.ts');
const INDEX_OUTPUT = path.join(GENERATED_DIR, 'index.ts');
const INDEX_JSON_PATH = path.join(SPECS_DIR, 'index.json');
const SCOPE_OVERRIDES_PATH = path.join(__dirname, 'generators', 'namespace-scope-overrides.json');
const DISPLAY_NAME_OVERRIDES_PATH = path.join(
  __dirname,
  'generators',
  'display-name-overrides.json',
);

/**
 * Generate the barrel export file for the generated module
 */
function generateIndexFile(): void {
  const content = `/**
 * Auto-generated module exports.
 * DO NOT EDIT - This file is generated by scripts/generate-resource-types.ts
 */

// Re-export all generated modules
export * from './constants';
export * from './resourceTypesBase';
export * from './documentationUrls';
export * from './domainCategories';
`;

  fs.writeFileSync(INDEX_OUTPUT, content, 'utf-8');
  console.log(`Generated: ${INDEX_OUTPUT}`);
}

/**
 * Print summary of key resource types for verification
 */
function printSummary(specs: ParsedSpecInfo[]): void {
  console.log('\n=== Generation Summary ===');
  console.log(`Total resource types generated: ${specs.length}`);

  const keyTypes = [
    'http_loadbalancer',
    'tcp_loadbalancer',
    'origin_pool',
    'app_firewall',
    'service_policy',
    'healthcheck',
    'dns_zone',
    'namespace',
  ];

  console.log('\nKey resource types:');
  for (const key of keyTypes) {
    const spec = specs.find((s) => s.resourceKey === key);
    if (spec) {
      const domain = spec.domain ? ` [${spec.domain}]` : '';
      console.log(`  ${key}: ${spec.apiPath} (${spec.apiBase})${domain}`);
    } else {
      console.log(`  ${key}: NOT FOUND`);
    }
  }

  // Count by API base
  const configCount = specs.filter((s) => s.apiBase === 'config').length;
  const webCount = specs.filter((s) => s.apiBase === 'web').length;
  console.log(`\nBy API base: config=${configCount}, web=${webCount}`);

  // Count namespace-scoped vs tenant-level
  const nsScoped = specs.filter((s) => s.namespaceScoped).length;
  const tenantLevel = specs.filter((s) => !s.namespaceScoped).length;
  console.log(`By scope: namespace-scoped=${nsScoped}, tenant-level=${tenantLevel}`);

  // Count by domain
  const domainCounts = new Map<string, number>();
  for (const spec of specs) {
    const domain = spec.domain || 'unknown';
    domainCounts.set(domain, (domainCounts.get(domain) || 0) + 1);
  }
  console.log(`\nBy domain (${domainCounts.size} domains):`);
  const sortedDomains = [...domainCounts.entries()].sort((a, b) => b[1] - a[1]);
  for (const [domain, count] of sortedDomains.slice(0, 10)) {
    console.log(`  ${domain}: ${count}`);
  }
  if (sortedDomains.length > 10) {
    console.log(`  ... and ${sortedDomains.length - 10} more domains`);
  }
}

/**
 * Main entry point
 */
function main(): void {
  console.log('Generating F5 XC resource types and constants...\n');

  // Ensure output directory exists
  if (!fs.existsSync(GENERATED_DIR)) {
    fs.mkdirSync(GENERATED_DIR, { recursive: true });
  }

  // Check if domain directory exists
  if (!fs.existsSync(DOMAIN_DIR)) {
    console.error(`Error: Domain directory not found: ${DOMAIN_DIR}`);
    console.error('Please ensure OpenAPI spec files are in docs/specifications/domains/');
    process.exit(1);
  }

  // Generate resource types from domain files (with namespace scope and display name overrides)
  console.log('Phase 1: Generating resource types from domain files...');
  const specs = generateResourceTypesFromDomainFiles(
    DOMAIN_DIR,
    RESOURCE_TYPES_OUTPUT,
    SCOPE_OVERRIDES_PATH,
    DISPLAY_NAME_OVERRIDES_PATH,
  );

  if (specs.length === 0) {
    console.error('Error: No resource types were generated');
    process.exit(1);
  }

  // Generate constants file
  console.log('\nPhase 2: Generating constants file...');
  writeConstantsFile(CONSTANTS_OUTPUT);

  // Generate domain categories from index.json (uses ui_category directly from upstream)
  console.log('\nPhase 3: Generating domain categories from index.json...');
  if (fs.existsSync(INDEX_JSON_PATH)) {
    generateDomainCategoriesFile(INDEX_JSON_PATH, DOMAIN_CATEGORIES_OUTPUT);
  } else {
    console.warn(`Warning: index.json not found at ${INDEX_JSON_PATH}, skipping domain categories`);
  }

  // Generate index file
  console.log('\nPhase 4: Generating index file...');
  generateIndexFile();

  // Print summary
  printSummary(specs);

  console.log('\n=== Generation Complete ===');
  console.log(`Output directory: ${GENERATED_DIR}`);
  console.log(`Files generated:`);
  console.log(`  - resourceTypesBase.ts (${specs.length} resource types)`);
  console.log(`  - constants.ts`);
  console.log(`  - domainCategories.ts`);
  console.log(`  - index.ts`);
}

main();
